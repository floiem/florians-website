import * as PImage from "pureimage"
import fs from "fs"
import { readFile } from "fs/promises"

const pretendard = PImage.registerFont(
  "build/assets/Pretendard-SemiBold.ttf",
  "Pretendard"
)
pretendard.loadSync()

// Recursive function to process all files in a directory
const processDirectory = async (dir) => {
  const files = await fs.promises.readdir(dir)
  for (const file of files.filter((f) => !f.startsWith("."))) {
    const filePath = `${dir}/${file}`
    const stats = await fs.promises.stat(filePath)

    if (stats.isDirectory()) {
      await processDirectory(filePath) // Recursively process subdirectories
    } else if (stats.isFile()) {
      await generateImage(filePath, dir, file)
    }
  }
}

// Start processing from the root directory
processDirectory("./content").then(() => {
  fs.writeFile(
    "./public/generated/readme.md",
    `# This folder is autogenerated\nIt contains all the images that are generated by the build step. Do not edit these files, they will be overwritten on the next build step.`,
    (err) => {
      if (err) throw err
    }
  )
})

const generateImage = async (path, folder, file) => {
  const markdown = await readFile(path, "utf-8")
  const properties = markdown.match(/---(.*?)---/s)[1].split("\n")

  const info = {}
  for (const property of properties) {
    if (property === "") continue
    const key = property.split(": ")[0]
    const value = property.split(": ")[1]
    info[key] = value
  }

  const frame = PImage.make(1200, 600)
  const ctx = frame.getContext("2d")

  ctx.fillStyle = "#fcfcfc"
  ctx.fillRect(0, 0, 1200, 600)

  ctx.fillStyle = "black"
  ctx.font = "56pt Pretendard"
  ctx.fillText(info.title, 152, 128)

  if (folder === "feed") {
    if (info.description.length > 64) {
      ctx.fillStyle = "#a1a1aa"
      ctx.font = "32pt Pretendard"
      ctx.fillText(info.description.slice(0, 70), 152, 198)
      ctx.fillText(info.description.slice(70, 150) + "...", 152, 248)
    } else {
      ctx.fillStyle = "#a1a1aa"
      ctx.font = "32pt Pretendard"
      ctx.fillText(
        info.description.length > 64
          ? info.description.slice(0, 70) + "..."
          : info.description,
        152,
        198
      )
    }
  } else {
    ctx.fillStyle = "#a1a1aa"
    ctx.font = "32pt Pretendard"
    ctx.fillText(
      info.description.length > 64
        ? info.description.slice(0, 70) + "..."
        : info.description,
      152,
      198
    )
  }

  if (info.cover && info.cover.includes(".jpg")) {
    const publicRoot = "./public"

    await PImage.decodeJPEGFromStream(
      fs.createReadStream(`${publicRoot}${info.cover}`)
    )
      .then((img) => {
        // img width and height should be accordingly calculated
        // to contain the same aspect ratio, but the widht should
        // be exactly 1040
        ctx.drawImage(img, 152, 280, 896, 560)
      })
      .catch((e) => console.log("Error: ", e))
  } else if (info.cover && info.cover.includes(".png")) {
    const publicRoot = "./public"

    await PImage.decodePNGFromStream(
      fs.createReadStream(`${publicRoot}${info.cover}`)
    )
      .then((img) => {
        // img width and height should be accordingly calculated
        // to contain the same aspect ratio, but the widht should
        // be exactly 1040
        ctx.drawImage(img, 152, 280, 896, 560)
      })
      .catch((e) => console.log("Error: ", e))
  }

  PImage.encodeJPEGToStream(
    frame,
    fs.createWriteStream(`./public/generated/${file.replace(".md", "")}.jpg`)
  )
    .then(() => {
      console.info(`Generated the opengraph image for ${file}`)
    })
    .catch((e) => {
      console.error("there was an error writing:", e)
    })
}

fs.writeFile(
  "./public/generated/readme.md",
  `# This folder is autogenerated
    
It contains all the images that are generated by the build step. Do not edit these files, they will be overwritten on the next build step.`,
  (err) => {
    if (err) throw err
  }
)
